
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyfrbus.frbus &#8212; pyFRB/US  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/nature.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pyFRB/US  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pyfrbus.frbus</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyfrbus.frbus</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">lxml.etree</span> <span class="k">as</span> <span class="nn">ElementTree</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c1"># For mypy typing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">lxml.etree</span> <span class="kn">import</span> <span class="n">Element</span>
<span class="kn">from</span> <span class="nn">pandas.core.frame</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ndarray</span>
<span class="kn">from</span> <span class="nn">symengine.lib.symengine_wrapper</span> <span class="kn">import</span> <span class="n">Expr</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Period</span><span class="p">,</span> <span class="n">PeriodIndex</span>

<span class="c1"># Imports from this package</span>
<span class="kn">import</span> <span class="nn">pyfrbus.xml_model</span> <span class="k">as</span> <span class="nn">xml_model</span>
<span class="kn">import</span> <span class="nn">pyfrbus.equations</span> <span class="k">as</span> <span class="nn">equations</span>
<span class="kn">import</span> <span class="nn">pyfrbus.run</span> <span class="k">as</span> <span class="nn">run</span>
<span class="kn">import</span> <span class="nn">pyfrbus.symbolic</span> <span class="k">as</span> <span class="nn">symbolic</span>
<span class="kn">from</span> <span class="nn">pyfrbus.block_ordering</span> <span class="kn">import</span> <span class="n">BlockOrdering</span>
<span class="kn">import</span> <span class="nn">pyfrbus.jacobian</span> <span class="k">as</span> <span class="nn">jacobian</span>
<span class="kn">import</span> <span class="nn">pyfrbus.solver</span> <span class="k">as</span> <span class="nn">solver</span>
<span class="kn">from</span> <span class="nn">pyfrbus.solver_opts</span> <span class="kn">import</span> <span class="n">solver_defaults</span>
<span class="kn">import</span> <span class="nn">pyfrbus.mcontrol</span> <span class="k">as</span> <span class="nn">mcontrol</span>
<span class="kn">import</span> <span class="nn">pyfrbus.stochsim</span> <span class="k">as</span> <span class="nn">stochsim</span>
<span class="kn">from</span> <span class="nn">pyfrbus.lib</span> <span class="kn">import</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">np2df</span><span class="p">,</span> <span class="n">idx_dict</span>
<span class="kn">from</span> <span class="nn">pyfrbus.data_lib</span> <span class="kn">import</span> <span class="n">drop_mce_vars</span><span class="p">,</span> <span class="n">copy_fwd_to_current</span><span class="p">,</span> <span class="n">get_fwd_vars</span>
<span class="kn">import</span> <span class="nn">pyfrbus.lexing</span> <span class="k">as</span> <span class="nn">lexing</span>
<span class="kn">import</span> <span class="nn">pyfrbus.constants</span> <span class="k">as</span> <span class="nn">constants</span>
<span class="kn">from</span> <span class="nn">pyfrbus.exceptions</span> <span class="kn">import</span> <span class="n">InvalidArgumentError</span><span class="p">,</span> <span class="n">MissingDataError</span>


<div class="viewcode-block" id="Frbus"><a class="viewcode-back" href="../../frbus.html#pyfrbus.frbus.Frbus">[docs]</a><span class="k">class</span> <span class="nc">Frbus</span><span class="p">:</span>
<div class="viewcode-block" id="Frbus.__init__"><a class="viewcode-back" href="../../frbus.html#pyfrbus.frbus.Frbus.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">mce</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize FRB/US model object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath: str</span>
<span class="sd">            Path to FRB/US model file in .xml format</span>
<span class="sd">        mce: Optional[str]</span>
<span class="sd">            Option to load MCE equations.</span>
<span class="sd">            Valid MCE types are ``all``, ``mcap``, ``wp``, and ``mcap+wp``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Frbus</span>
<span class="sd">            FRB/US model object</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Parse model XML file</span>
        <span class="n">xml</span><span class="p">:</span> <span class="n">Element</span> <span class="o">=</span> <span class="n">ElementTree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>

        <span class="c1"># Names of endogenous variables</span>
        <span class="c1"># orig_ fields are the ones read from XML</span>
        <span class="c1"># others may be edited during model setup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_endo_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">xml_model</span><span class="o">.</span><span class="n">endo_names_from_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_endo_names</span><span class="p">)</span>
        <span class="c1"># Corresponding equations</span>
        <span class="n">eqs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">xml_model</span><span class="o">.</span><span class="n">equations_from_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
        <span class="c1"># Constants from those equations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">xml_model</span><span class="o">.</span><span class="n">constants_from_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
        <span class="c1"># Variables to be shocked in stochastic sims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stoch_shocks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">xml_model</span><span class="o">.</span><span class="n">stoch_shocks</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>

        <span class="c1"># Read in MCE equations/constants if needed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_leads</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">mce</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mce</span><span class="p">:</span>
            <span class="c1"># Throw error if invalid mce type is given</span>
            <span class="k">if</span> <span class="n">mce</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">constants</span><span class="o">.</span><span class="n">CONST_MCE_TYPES</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidArgumentError</span><span class="p">(</span><span class="s2">&quot;Frbus constructor&quot;</span><span class="p">,</span> <span class="s2">&quot;mce&quot;</span><span class="p">,</span> <span class="n">mce</span><span class="p">)</span>
            <span class="p">(</span><span class="n">mce_eqs</span><span class="p">,</span> <span class="n">mce_vars</span><span class="p">)</span> <span class="o">=</span> <span class="n">xml_model</span><span class="o">.</span><span class="n">mce_from_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span> <span class="n">mce</span><span class="p">)</span>
            <span class="n">mce_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">mce_vars</span><span class="p">]</span>
            <span class="c1"># Replace equations with MCE version</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">eq</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mce_idxs</span><span class="p">,</span> <span class="n">mce_eqs</span><span class="p">):</span>
                <span class="n">eqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">eq</span>
            <span class="c1"># Add/replace constants</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">xml_model</span><span class="o">.</span><span class="n">mce_constants_from_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">,</span> <span class="n">mce</span><span class="p">))</span>

        <span class="c1"># Add tracking residual variables</span>
        <span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">eqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;+</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">_trac&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">eqs</span><span class="p">))]</span>

        <span class="c1"># Names of exogenous variables</span>
        <span class="c1"># First we must drop unused series from the model.xml</span>
        <span class="n">tmp_exos</span> <span class="o">=</span> <span class="n">xml_model</span><span class="o">.</span><span class="n">exo_names_from_xml</span><span class="p">(</span><span class="n">xml</span><span class="p">)</span>
        <span class="n">tmp_exos</span> <span class="o">=</span> <span class="p">[</span><span class="n">exo</span> <span class="k">for</span> <span class="n">exo</span> <span class="ow">in</span> <span class="n">tmp_exos</span> <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">exo</span> <span class="ow">in</span> <span class="n">eq</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">eqs</span><span class="p">])]</span>
        <span class="c1"># Add in _aerrs and _tracs for every endogenous variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_exo_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_exos</span> <span class="o">+</span> <span class="p">[</span>
            <span class="n">endo</span> <span class="o">+</span> <span class="s2">&quot;_aerr&quot;</span> <span class="k">for</span> <span class="n">endo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span>
        <span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">endo</span> <span class="o">+</span> <span class="s2">&quot;_trac&quot;</span> <span class="k">for</span> <span class="n">endo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exo_names</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_exo_names</span><span class="p">)</span>

        <span class="c1"># Fill in constants</span>
        <span class="n">filled_eqs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">equations</span><span class="o">.</span><span class="n">fill_constants</span><span class="p">(</span>
            <span class="p">[</span><span class="n">equations</span><span class="o">.</span><span class="n">flip_equals</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">eqs</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span>
        <span class="p">)</span>

        <span class="c1"># Lex to separate variable identifier from everything else</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_lexed_eqs</span> <span class="o">=</span> <span class="n">lexing</span><span class="o">.</span><span class="n">lex_eqs</span><span class="p">(</span><span class="n">filled_eqs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexed_eqs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_lexed_eqs</span><span class="p">)</span>

        <span class="c1"># Field to store dataframe column names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_varnames</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># List of additional exogenous variables, specified at runtime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exoglist</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># Model updated flags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exoglist_changed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eqs_changed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Substituted equation placeholder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xsub</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Jacobian placeholder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jac</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="c1"># Takes a list of endogenous variables to exogenize</span>
<div class="viewcode-block" id="Frbus.exogenize"><a class="viewcode-back" href="../../frbus.html#pyfrbus.frbus.Frbus.exogenize">[docs]</a>    <span class="k">def</span> <span class="nf">exogenize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exoglist</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exogenize a list of endogenous variables in the model.</span>

<span class="sd">        This function takes a list of endogenous variables present in the model and</span>
<span class="sd">        transforms them into exogenous variables.</span>
<span class="sd">        Note: all variables that you want to be exogenous must</span>
<span class="sd">        be passed in as `exoglist` at the same time. Calling ``exogenize`` twice in a</span>
<span class="sd">        row will give a model with only the second `exoglist` variables exogenized.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        exoglist: List[str]</span>
<span class="sd">            List of endogenous model variables</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">exoglist</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exoglist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exoglist_changed</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="c1"># Add a set of equations to the model</span>
    <span class="c1"># Replaces equations if the endo already exists</span>
    <span class="c1"># Input is a map of endo name -&gt; equation string</span>
    <span class="c1"># Dict MUST INCLUDE all new endos used in other new equations</span>
<div class="viewcode-block" id="Frbus.append_replace"><a class="viewcode-back" href="../../frbus.html#pyfrbus.frbus.Frbus.append_replace">[docs]</a>    <span class="k">def</span> <span class="nf">append_replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eqs_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append new equations to the model, or replace existing equations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        eqs_map: Dict[str, str]</span>
<span class="sd">            Dictionary mapping equation names to equations</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># First, standardize format by cleaning equations and removing =</span>
        <span class="c1"># And append tracking residuals</span>
        <span class="n">eqs_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">endo</span><span class="p">:</span> <span class="n">equations</span><span class="o">.</span><span class="n">flip_equals</span><span class="p">(</span><span class="n">equations</span><span class="o">.</span><span class="n">clean_eq</span><span class="p">(</span><span class="n">eq</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;+</span><span class="si">{</span><span class="n">endo</span><span class="si">}</span><span class="s2">_trac&quot;</span><span class="p">))</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">endo</span><span class="p">,</span> <span class="n">eq</span><span class="p">)</span> <span class="ow">in</span> <span class="n">eqs_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># Split endos; old_endos is replaced, new_endos is appended</span>
        <span class="n">old_endos_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">endo</span><span class="p">:</span> <span class="n">eq</span> <span class="k">for</span> <span class="p">(</span><span class="n">endo</span><span class="p">,</span> <span class="n">eq</span><span class="p">)</span> <span class="ow">in</span> <span class="n">eqs_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">endo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_endo_names</span>
        <span class="p">}</span>
        <span class="n">new_endos_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">endo</span><span class="p">:</span> <span class="n">eq</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">endo</span><span class="p">,</span> <span class="n">eq</span><span class="p">)</span> <span class="ow">in</span> <span class="n">eqs_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">endo</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_endo_names</span>
        <span class="p">}</span>
        <span class="c1"># Append new endos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_endo_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_endo_names</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_endos_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_endo_names</span><span class="p">)</span>

        <span class="c1"># Replace equations for old endos</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">endo</span><span class="p">,</span> <span class="n">repl_eq</span><span class="p">)</span> <span class="ow">in</span> <span class="n">old_endos_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_endo_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">endo</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">orig_lexed_eqs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">lexing</span><span class="o">.</span><span class="n">lex_eq</span><span class="p">(</span><span class="n">repl_eq</span><span class="p">)</span>

        <span class="c1"># Append new endo equations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_lexed_eqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_lexed_eqs</span> <span class="o">+</span> <span class="p">[</span>
            <span class="n">lexing</span><span class="o">.</span><span class="n">lex_eq</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">new_endos_map</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexed_eqs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_lexed_eqs</span><span class="p">)</span>

        <span class="c1"># Assemble list of tokens which are not new exos</span>
        <span class="c1"># i.e. functions, endos, and old exos</span>
        <span class="n">ban_list</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">constants</span><span class="o">.</span><span class="n">CONST_SUPPORTED_FUNCTIONS_EX</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">exo_names</span>
        <span class="p">)</span>

        <span class="c1"># Any token in an equation that is NOT an endo is assumed to be an exo</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">([</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[^\w]&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">eq</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">eqs_map</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

        <span class="c1"># We want unique new tokens</span>
        <span class="c1"># We use dict-&gt;list instead of set because it preserves order</span>
        <span class="n">new_exos</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">token</span><span class="p">:</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">tokens</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ban_list</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\d&quot;</span><span class="p">,</span> <span class="n">token</span><span class="p">))</span>
        <span class="p">}</span>

        <span class="c1"># Update has_leads if appended equations are forward-looking</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_leads</span> <span class="o">=</span> <span class="n">equations</span><span class="o">.</span><span class="n">has_leads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lexed_eqs</span><span class="p">)</span>

        <span class="c1"># Add new exos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_exo_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_exo_names</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_exos</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exo_names</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_exo_names</span><span class="p">)</span>

        <span class="c1"># Ensure that xsub, etc. is regenerated when model is next used</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eqs_changed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># Also because endo_names is updated, may need to re-exogenize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exoglist_changed</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="c1"># Adds missing aerrs to dataframe, along with tracking residuals</span>
    <span class="c1"># Exogenizes additional variables from .exogenize</span>
    <span class="c1"># Substitutes references to &quot;x&quot;, &quot;data&quot; in equations</span>
    <span class="c1"># Turns equations into lambdas</span>
    <span class="k">def</span> <span class="nf">_solve_setup</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">single_block</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>

        <span class="c1"># First, make a copy of input data to be returned</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Add missing variables</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_fix_errs_in_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span><span class="p">)</span>

        <span class="c1"># Exogenize specified variables, if necessary</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exoglist_changed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reset_model</span><span class="p">()</span>

        <span class="c1"># If MCE, fill in columns for fwd-looking equations</span>
        <span class="c1"># We do this every time, as they get wiped before data is returned to the user</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_leads</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">_populate_mce_data</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;Q&quot;</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="c1"># Check if equation setup needs to be run</span>
        <span class="c1"># Get names of columns in DataFrame</span>
        <span class="c1"># If they are the same as last time, we do not need to run setup</span>
        <span class="c1"># as data indices will be correct.</span>
        <span class="c1"># UNLESS equations have been added/modified</span>
        <span class="c1"># or the requested block decomposition is different from the stored one</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_varnames</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">eqs_changed</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;blocks&quot;</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">((</span><span class="n">single_block</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_leads</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">single_block</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_leads</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">):</span>

            <span class="c1"># If there are leads, do MCE setup</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_leads</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mce_setup</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

            <span class="c1"># Store names of data frame columns</span>
            <span class="c1"># Important, related to how lags/exos are substituted in equations</span>
            <span class="c1"># If dataset changes, we need to redo the setup</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_varnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="c1"># Convert endo names into indices in numpy arrays</span>
            <span class="c1"># Gives a mapping colname -&gt; index for a dataframe</span>
            <span class="c1"># Used to speed up multi-gets and multi-sets</span>
            <span class="n">data_varnames_idx_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_dict</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endo_idxs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">data_varnames_idx_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span>
                <span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MissingDataError</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="kn">from</span> <span class="bp">None</span>

            <span class="c1"># Reset model changed flag</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eqs_changed</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Turn equations into expressions that = 0</span>
            <span class="c1"># Fill in lags and exos, so only contemporaneous terms remain</span>
            <span class="c1"># Pass in data_varnames so fill_lags and fill_exos have correct indexes</span>
            <span class="c1"># Replace variable names with x[i]s so it can be eval&#39;d</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xsub</span> <span class="o">=</span> <span class="n">equations</span><span class="o">.</span><span class="n">fill_lags_and_exos_xsub</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lexed_eqs</span><span class="p">,</span> <span class="n">data_varnames_idx_dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exo_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span>
            <span class="p">)</span>

            <span class="c1"># Corresponding functions, as lambdas with arguments x, data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generic_feqs</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">],</span> <span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">run</span><span class="o">.</span><span class="n">fun_form</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xsub</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Convert equation to SymPy/SymEngine exprs, for equation solving, jacobian</span>
            <span class="c1"># Tokens like data[-i,j] are converted to data[k]</span>
            <span class="c1"># in some array of &quot;data&quot; symbols, so SymEngine can understand them</span>
            <span class="c1"># data_hash is the mapping  data[k] =&gt; data[-i,j]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Expr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_hash</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_hash</span> <span class="o">=</span> <span class="n">symbolic</span><span class="o">.</span><span class="n">to_symengine_expr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xsub</span><span class="p">)</span>

            <span class="c1"># Set up Jacobian, if needed</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">jac</span><span class="p">:</span>
                <span class="c1"># Compute Jacobian</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_leads</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">jac</span> <span class="o">=</span> <span class="n">jacobian</span><span class="o">.</span><span class="n">mce_create_jacobian</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xsub</span><span class="p">),</span>
                        <span class="n">equations</span><span class="o">.</span><span class="n">rhs_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xsub</span><span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data_hash</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data_varnames</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">jac</span> <span class="o">=</span> <span class="n">jacobian</span><span class="o">.</span><span class="n">create_jacobian</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xsub</span><span class="p">),</span>
                        <span class="n">equations</span><span class="o">.</span><span class="n">rhs_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xsub</span><span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data_hash</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="c1"># Compute block ordering</span>
            <span class="c1"># Always use single block if MCE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">:</span> <span class="n">BlockOrdering</span> <span class="o">=</span> <span class="n">BlockOrdering</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xsub</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_hash</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span><span class="p">,</span>
                <span class="n">single_block</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_leads</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generic_feqs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Add Jacobian to the block ordering</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">add_jac</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jac</span><span class="p">)</span>

        <span class="c1"># Return fixed data</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="c1"># Setup required for MCE simulations</span>
    <span class="k">def</span> <span class="nf">_mce_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># First, reset MCE state in case setup has already been run</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_model</span><span class="p">()</span>

        <span class="c1"># Number of periods to terminal period</span>
        <span class="n">periods</span><span class="p">:</span> <span class="n">PeriodIndex</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;Q&quot;</span><span class="p">)</span>
        <span class="n">n_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">periods</span><span class="p">)</span>

        <span class="c1"># Duplicate endogenous variables as leads</span>
        <span class="n">dupe_endos</span> <span class="o">=</span> <span class="n">equations</span><span class="o">.</span><span class="n">dupe_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span><span class="p">,</span> <span class="n">n_periods</span><span class="p">)</span>
        <span class="c1"># Duplicate exogenous variables as leads</span>
        <span class="n">dupe_exos</span> <span class="o">=</span> <span class="n">equations</span><span class="o">.</span><span class="n">dupe_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exo_names</span><span class="p">,</span> <span class="n">n_periods</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span> <span class="o">+=</span> <span class="n">dupe_endos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exo_names</span> <span class="o">+=</span> <span class="n">dupe_exos</span>

        <span class="c1"># Build stacked time system by duplicating equations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexed_eqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexed_eqs</span> <span class="o">+</span> <span class="n">equations</span><span class="o">.</span><span class="n">dupe_eqs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lexed_eqs</span><span class="p">,</span> <span class="n">n_periods</span><span class="p">)</span>

        <span class="c1"># Handle terminal condition: if period &gt; end</span>
        <span class="c1"># Terminals are substituted, data from start_date+period</span>
        <span class="n">start_date</span><span class="p">:</span> <span class="n">Period</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

        <span class="c1"># Turn leads into new contemporaneous variables</span>
        <span class="c1"># and substitute out terminal condition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexed_eqs</span> <span class="o">=</span> <span class="n">lexing</span><span class="o">.</span><span class="n">remove_leads</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lexed_eqs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">n_periods</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="c1"># Method to reset model state from original state</span>
    <span class="k">def</span> <span class="nf">_reset_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Reset endos, exos, and equations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_endo_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exo_names</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_exo_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexed_eqs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_lexed_eqs</span><span class="p">)</span>

        <span class="c1"># Remove corresponding endos and equations,</span>
        <span class="c1"># add vars to list of exos</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exoglist</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">]</span>
        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">lexed_eqs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idxs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exo_names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exoglist</span><span class="p">)</span>

        <span class="c1"># And ensure that none of the original exos have been given equations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exo_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">exo</span> <span class="k">for</span> <span class="n">exo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exo_names</span> <span class="k">if</span> <span class="n">exo</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span><span class="p">]</span>

        <span class="c1"># Delete previous Jacobian</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jac</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Indicate that equations need to be re-generated</span>
        <span class="c1"># to change newly exog variables and point them to &quot;data&quot; instead of &quot;x&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eqs_changed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># Exoglist is now consistent with model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exoglist_changed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Initialize addfactors (_trac) from start to end, based on input_data</span>
    <span class="c1"># Returns a data frame with the _trac values filled in</span>
<div class="viewcode-block" id="Frbus.init_trac"><a class="viewcode-back" href="../../frbus.html#pyfrbus.frbus.Frbus.init_trac">[docs]</a>    <span class="k">def</span> <span class="nf">init_trac</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Period</span><span class="p">],</span> <span class="n">end</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Period</span><span class="p">],</span> <span class="n">input_data</span><span class="p">:</span> <span class="n">DataFrame</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize tracking residuals (add-factors).</span>

<span class="sd">        Given a baseline dataset `input_data` and a date range `start` to `end`,</span>
<span class="sd">        ``init_trac`` will compute tracking residuals such that each equation will solve</span>
<span class="sd">        to the trajectory given for that variable in `input_data`.</span>
<span class="sd">        As in, ``output = model.init_trac(start, end, input_data)``, then</span>
<span class="sd">        ``model.solve(start, end, output)`` will be the same as ``output``.</span>

<span class="sd">        Tracking residuals are stored in additional columns in ``output``, named</span>
<span class="sd">        according to their respective endogenous variables, e.g. the tracking residual</span>
<span class="sd">        for ``xgdp`` is stored as ``xgdp_trac``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start: Union[str, Period]</span>
<span class="sd">            Date to begin computing residuals</span>

<span class="sd">        end: Union[str, Period]</span>
<span class="sd">            Date to end residuals (inclusive)</span>

<span class="sd">        input_data: DataFrame</span>
<span class="sd">            Dataset with trajectories that residuals are computed with respect to</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output: DataFrame</span>
<span class="sd">            `input_data` plus columns for tracking residuals</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set up substituted equations, data</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_setup</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

        <span class="c1"># Create frame with initialized _tracs</span>
        <span class="c1"># We only need them for one period in the MCE solver</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_leads</span><span class="p">:</span>
            <span class="n">with_adds</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">init_trac</span><span class="p">(</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endo_idxs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_feqs</span>
            <span class="p">)</span>
            <span class="c1"># Copy fwd-looking _tracs to their contemporaneous versions before we drop</span>
            <span class="n">fwd_endos</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">get_fwd_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span><span class="p">))</span>
            <span class="n">errs</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_trac&quot;</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span> <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fwd_endos</span><span class="p">]</span>
            <span class="n">with_adds</span> <span class="o">=</span> <span class="n">copy_fwd_to_current</span><span class="p">(</span>
                <span class="n">with_adds</span><span class="p">,</span> <span class="n">errs</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;Q&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Drop MCE columns and return</span>
            <span class="k">return</span> <span class="n">drop_mce_vars</span><span class="p">(</span><span class="n">with_adds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">solver</span><span class="o">.</span><span class="n">init_trac</span><span class="p">(</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endo_idxs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_feqs</span>
            <span class="p">)</span></div>

    <span class="c1"># Solves the model from start to end on input data</span>
    <span class="c1"># Returns a data frame with endo solutions filled in</span>
<div class="viewcode-block" id="Frbus.solve"><a class="viewcode-back" href="../../frbus.html#pyfrbus.frbus.Frbus.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Period</span><span class="p">],</span>
        <span class="n">end</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Period</span><span class="p">],</span>
        <span class="n">input_data</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the model over the given dataset.</span>

<span class="sd">        Given the DataFrame `input_data`, this procedure returns the model solution</span>
<span class="sd">        over the period from `start` to `end`. Detailed information on the solution</span>
<span class="sd">        algorithm can be found in the User Guide.</span>

<span class="sd">        ``Frbus.solve`` will solve both backwards-looking VAR and forwards-looking MCE</span>
<span class="sd">        (model-consistent expectations/rational expectations) models. The `options`</span>
<span class="sd">        dictionary can be passed to configure the solution algorithm, as specified</span>
<span class="sd">        below.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start: Union[str, Period]</span>
<span class="sd">            Date to begin computing solution</span>

<span class="sd">        end: Union[str, Period]</span>
<span class="sd">            Date to end solution (inclusive)</span>

<span class="sd">        input_data: DataFrame</span>
<span class="sd">            Dataset to solve over</span>

<span class="sd">        options: Optional[Dict]</span>
<span class="sd">            Options to pass to solver:</span>
<span class="sd">                ``newton: Optional[str]``</span>
<span class="sd">                    Whether to use sparse Newton&#39;s method solver (``&quot;newton&quot;``),</span>
<span class="sd">                    sparse trust-region solver (``&quot;trust&quot;``), or dense solver from SciPy</span>
<span class="sd">                    (``None``).</span>
<span class="sd">                    Defaults to ``None``.</span>
<span class="sd">                ``single_block: bool``</span>
<span class="sd">                    When set to ``True``, disables the VAR  block decomposition step.</span>
<span class="sd">                    Defaults to ``False``.</span>
<span class="sd">                ``debug: bool``</span>
<span class="sd">                    When set to ``True``, enables verbose output of solver status.</span>
<span class="sd">                    Defaults to ``False``.</span>
<span class="sd">                ``xtol: float``</span>
<span class="sd">                    Set stepsize termination condition for Newton and trust-region</span>
<span class="sd">                    algorithms. Use a smaller value for more precise solution, at the</span>
<span class="sd">                    expense of runtime. Defaults to ``1e-6``.</span>
<span class="sd">                ``rtol: float``</span>
<span class="sd">                    Set residual termination condition for Newton and trust-region</span>
<span class="sd">                    algorithms. Solver will fail if step reaches ``xtol`` but residual</span>
<span class="sd">                    is greater than ``rtol``. Defaults to ``5e-4``.</span>
<span class="sd">                ``maxiter: int``</span>
<span class="sd">                    Maximum number of iterations for Newton and trust-region algorithms.</span>
<span class="sd">                    Solver will fail if algorithm iterates ``maxiter`` times without</span>
<span class="sd">                    reaching ``xtol``. Increase to allow more time for convergence.</span>
<span class="sd">                    Defaults to ``50``.</span>
<span class="sd">                ``trust_radius: float``</span>
<span class="sd">                    Maximum size of the trust radius in trust-region algorithm. Altering</span>
<span class="sd">                    radius can change convergence path. Defaults to ``1000000``.</span>
<span class="sd">                ``precond: bool``</span>
<span class="sd">                    When set to ``True``, use matrix preconditioner to decrease</span>
<span class="sd">                    condition number of Jacobian. Disable if it causes problems.</span>
<span class="sd">                    Defaults to ``True``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output: DataFrame</span>
<span class="sd">            Dataset shaped like `input_data`, with trajectories for endogenous variables</span>
<span class="sd">            produced by model solution between `start` and `end`, inclusive. Data in</span>
<span class="sd">            `output` from outside this period is identical to `input_data`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get defaults for omitted options</span>
        <span class="n">options</span> <span class="o">=</span> <span class="n">solver_defaults</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>

        <span class="c1"># Set up substituted equations, data, jacobian</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_solve_setup</span><span class="p">(</span>
            <span class="n">input_data</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;single_block&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Solve for period start:end (inclusive)</span>
        <span class="c1"># Call the MCE solver if there are leads</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_leads</span><span class="p">:</span>
            <span class="c1"># MCE assumes model has been setup in stacked time format</span>
            <span class="c1"># Solves for a single period and substitutes endo data from leads</span>
            <span class="c1"># Defaults to Newton if not specified</span>
            <span class="n">options</span><span class="p">[</span><span class="s2">&quot;newton&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;newton&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="s2">&quot;newton&quot;</span>
            <span class="n">soln</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span>
                <span class="n">start</span><span class="p">,</span>
                <span class="n">start</span><span class="p">,</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endo_idxs</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generic_feqs</span><span class="p">,</span>
                <span class="n">options</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Copy single-period solution back to original columns</span>
            <span class="n">fwd_endos</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">get_fwd_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span><span class="p">))</span>
            <span class="n">var_endo_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">endo_names</span> <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fwd_endos</span><span class="p">]</span>
            <span class="n">soln</span> <span class="o">=</span> <span class="n">copy_fwd_to_current</span><span class="p">(</span>
                <span class="n">soln</span><span class="p">,</span> <span class="n">var_endo_names</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">period_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="s2">&quot;Q&quot;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Drop MCE columns and return</span>
            <span class="k">return</span> <span class="n">drop_mce_vars</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span>
                <span class="n">start</span><span class="p">,</span>
                <span class="n">end</span><span class="p">,</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endo_idxs</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">generic_feqs</span><span class="p">,</span>
                <span class="n">options</span><span class="p">,</span>
            <span class="p">)</span></div>

    <span class="c1"># Solves the model while forcing the target variable to the specified trajectory</span>
    <span class="c1"># by moving the instrument</span>
<div class="viewcode-block" id="Frbus.mcontrol"><a class="viewcode-back" href="../../frbus.html#pyfrbus.frbus.Frbus.mcontrol">[docs]</a>    <span class="k">def</span> <span class="nf">mcontrol</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Period</span><span class="p">],</span>
        <span class="n">end</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Period</span><span class="p">],</span>
        <span class="n">input_data</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">targ</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">inst</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve model, forcing target variables to specified trajectories.</span>

<span class="sd">        ``mcontrol`` is a trajectory-matching control procedure which adjusts the value</span>
<span class="sd">        of instrument variables such that target variables are forced to specified</span>
<span class="sd">        trajectories, as mediated by the model&#39;s dynamics.</span>

<span class="sd">        `targ` is a list of model variables (&quot;targets&quot;), and `traj` is the list of</span>
<span class="sd">        series in `input_data` that those variables should be forced to</span>
<span class="sd">        (&quot;trajectories&quot;), in the same order; e.g. the first variable in `targ` is</span>
<span class="sd">        matched to the first trajectory in `traj`, etc.</span>

<span class="sd">        `inst` is a list of exogenous model variables (&quot;instruments&quot;) which will take</span>
<span class="sd">        on values such that the trajectories are achieved. The selected instruments may</span>
<span class="sd">        be unable to achieve the specified trajectories - e.g. because there is no</span>
<span class="sd">        instrument which is able to affect one or more of the specified targets, or</span>
<span class="sd">        because one or more of the specified trajectories contains an invalid value for</span>
<span class="sd">        that target variable. In that case, the model will fail to solve and an error</span>
<span class="sd">        will instruct you to verify that your setup for ``mcontrol`` is valid.</span>

<span class="sd">        Targets are only forced to their trajectories when a trajectory is present. A</span>
<span class="sd">        particular target can be disabled by setting the corresponding trajectory to</span>
<span class="sd">        ``numpy.nan`` over the date range where it should be inactive. When the</span>
<span class="sd">        trajectory is set to ``numpy.nan``, the corresponding target is allowed to take</span>
<span class="sd">        on the value produced by the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start: Union[str, Period]</span>
<span class="sd">            Date to begin computing solution</span>

<span class="sd">        end: Union[str, Period]</span>
<span class="sd">            Date to end solution (inclusive)</span>

<span class="sd">        input_data: DataFrame</span>
<span class="sd">            Dataset to solve over, including series for trajectories specified in `traj`</span>

<span class="sd">        targ: List[str]</span>
<span class="sd">            List of endogenous model variables to force (in order)</span>

<span class="sd">        traj: List[str]</span>
<span class="sd">            List of trajectories in `input_data` to force `targ` variables to (in order)</span>

<span class="sd">        inst: List[str]</span>
<span class="sd">            Instruments used to control forcing procedure</span>

<span class="sd">        options: Optional[Dict]</span>
<span class="sd">            Options passed to solver - see additional documentation under</span>
<span class="sd">            ``Frbus.solve``. Some options will be overridden if they are unable to be</span>
<span class="sd">            used with ``mcontrol`` procedure; ``mcontrol`` requires the use of either</span>
<span class="sd">            Newton or trust-region solvers (defaults to ``&quot;newton&quot;``) and requires</span>
<span class="sd">            ``single_block`` set to ``True``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output: DataFrame</span>
<span class="sd">            Dataset shaped like `input_data`, with a solution consistent with the</span>
<span class="sd">            specified forced trajectories between `start` and `end`, inclusive. Data</span>
<span class="sd">            from `output` outside this period is identical to `input_data`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">mcontrol</span><span class="o">.</span><span class="n">mcontrol</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">targ</span><span class="p">,</span> <span class="n">traj</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">options</span>
        <span class="p">)</span></div>

    <span class="c1"># Runs nrepl stochastic simulations from start to end on input data</span>
    <span class="c1"># Using specified residual dates for shock quarters, drawn IID</span>
    <span class="c1"># Returns a list of data frames for each replication</span>
<div class="viewcode-block" id="Frbus.stochsim"><a class="viewcode-back" href="../../frbus.html#pyfrbus.frbus.Frbus.stochsim">[docs]</a>    <span class="k">def</span> <span class="nf">stochsim</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nrepl</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">input_data</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">simstart</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Period</span><span class="p">],</span>
        <span class="n">simend</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Period</span><span class="p">],</span>
        <span class="n">residstart</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Period</span><span class="p">],</span>
        <span class="n">residend</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Period</span><span class="p">],</span>
        <span class="n">multiproc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">nextra</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs a series of simulations with shocks drawn from historical residuals.</span>

<span class="sd">        The ``stochsim`` procedure performs a stochastic simulation by applying</span>
<span class="sd">        sequences of shocks to the model, as drawn randomly from historical residuals.</span>
<span class="sd">        Before using this procedure, the DataFrame `input_data` must have residuals</span>
<span class="sd">        computed over both history and the simulation period with ``Frbus.init_trac&#39;``.</span>

<span class="sd">        The procedure begins by drawing `nrepl` sequences of quarters from the dataset</span>
<span class="sd">        `input_data` over the periods `residstart` to `residend`, where the length of</span>
<span class="sd">        that sequence goes from `simstart` to `simend`. That is, for a particular</span>
<span class="sd">        replication, each quarter in the simulation period is randomly assigned a</span>
<span class="sd">        quarter from residual period. In that quarter of the simulation, all stochastic</span>
<span class="sd">        variables (specified with a ``stochastic_type`` tag in the model) have a shock</span>
<span class="sd">        applied from a particular quarter in the residual period, where the shock values</span>
<span class="sd">        are pulled from the ``_trac`` variables in ``input_data`` - e.g., the variable</span>
<span class="sd">        ``xgdp`` is shocked with a value pulled from ``xgdp_trac`` over history.</span>

<span class="sd">        These scenarios are passed to the solver, in parallel if `multiproc` is set to</span>
<span class="sd">        ``True``, and the solutions are returned as a list of DataFrames. Any failed</span>
<span class="sd">        simulations will be returned as an error string. The argument `nextra` can be</span>
<span class="sd">        passed to allow the procedure to run extra simulations to replace those</span>
<span class="sd">        failures.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nrepl: int</span>
<span class="sd">            Number of simulations to run</span>

<span class="sd">        input_data: DataFrame</span>
<span class="sd">            Dataset to solve over</span>

<span class="sd">        simstart: Union[str, Period]</span>
<span class="sd">            Date to begin computing solution</span>

<span class="sd">        simend: Union[str, Period]</span>
<span class="sd">            Date to end solution (inclusive)</span>

<span class="sd">        residstart: Union[str, Period]</span>
<span class="sd">            Date to begin drawing shocks</span>

<span class="sd">        residend: Union[str, Period]</span>
<span class="sd">            Date to end drawing shocks (inclusive)</span>

<span class="sd">        multiproc: bool</span>
<span class="sd">            Option to run simulations in parallel</span>

<span class="sd">        nextra: int</span>
<span class="sd">            Option to specify how many additional simulations to run, in case of errors</span>

<span class="sd">        seed: int</span>
<span class="sd">            Random seed used when drawing shocks</span>

<span class="sd">        options: Optional[Dict]</span>
<span class="sd">            Options passed to solver - see additional documentation under</span>
<span class="sd">            ``Frbus.solve``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        solutions: List[Union[DataFrame, str]]</span>
<span class="sd">            List of datasets shaped like `input_data`, with solutions to stochastic</span>
<span class="sd">            simulations as returned from ``Frbus.solve``. List contains error strings</span>
<span class="sd">            instead of data for simulations that fail.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">stochsim</span><span class="o">.</span><span class="n">stochsim</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">nrepl</span><span class="p">,</span>
            <span class="n">input_data</span><span class="p">,</span>
            <span class="n">simstart</span><span class="p">,</span>
            <span class="n">simend</span><span class="p">,</span>
            <span class="n">residstart</span><span class="p">,</span>
            <span class="n">residend</span><span class="p">,</span>
            <span class="n">multiproc</span><span class="p">,</span>
            <span class="n">nextra</span><span class="p">,</span>
            <span class="n">seed</span><span class="p">,</span>
            <span class="n">options</span><span class="p">,</span>
        <span class="p">)</span></div>

    <span class="c1"># Define custom getstate/setstate for pickle and deepcopy</span>
    <span class="c1"># Delete symengine exprs before copying because they are not pickleable</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">has_exprs</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;exprs&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">has_exprs</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">has_exprs</span><span class="p">:</span>
            <span class="c1"># Restore exprs to original object</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newstate</span><span class="p">):</span>
        <span class="c1"># If it should have exprs, reconstruct them from xsub</span>
        <span class="k">if</span> <span class="s2">&quot;exprs&quot;</span> <span class="ow">in</span> <span class="n">newstate</span><span class="p">:</span>
            <span class="n">newstate</span><span class="p">[</span><span class="s2">&quot;exprs&quot;</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">symbolic</span><span class="o">.</span><span class="n">to_symengine_expr</span><span class="p">(</span><span class="n">newstate</span><span class="p">[</span><span class="s2">&quot;xsub&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">newstate</span><span class="p">)</span></div>


<span class="c1"># Make sure dataset includes a _aerr, _trac for each endogenous variable</span>
<span class="c1"># ex. USEGBX leaves out qlf_aerr, qlfpr_aerr</span>
<span class="k">def</span> <span class="nf">_fix_errs_in_data</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">endo_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
    <span class="c1"># Skip fwd-looking endos of the form &#39;zrff5_1&#39;</span>
    <span class="n">all_aerrs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">aerr</span>
        <span class="k">for</span> <span class="n">aerr</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">endo</span><span class="si">}</span><span class="s2">_aerr&quot;</span>
            <span class="k">for</span> <span class="n">endo</span> <span class="ow">in</span> <span class="n">endo_names</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;_\d+&quot;</span><span class="p">,</span> <span class="n">endo</span><span class="p">)</span> <span class="ow">and</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">endo</span><span class="si">}</span><span class="s2">_aerr&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">]</span>
    <span class="p">]</span>
    <span class="n">all_tracs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">aerr</span>
        <span class="k">for</span> <span class="n">aerr</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">endo</span><span class="si">}</span><span class="s2">_trac&quot;</span>
            <span class="k">for</span> <span class="n">endo</span> <span class="ow">in</span> <span class="n">endo_names</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;_\d+&quot;</span><span class="p">,</span> <span class="n">endo</span><span class="p">)</span> <span class="ow">and</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">endo</span><span class="si">}</span><span class="s2">_trac&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">]</span>
    <span class="p">]</span>
    <span class="c1"># Add to the data</span>
    <span class="c1"># Fastest method I&#39;ve found</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
        <span class="p">[</span><span class="n">data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">all_aerrs</span> <span class="o">+</span> <span class="n">all_tracs</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="c1"># Populate data frame with data for fwd-looking variables</span>
<span class="c1"># Only needed for the period start</span>
<span class="c1"># Exos need data, endos need a starting &quot;guess&quot; for the solver</span>
<span class="c1"># These are my hacks to try to speed up data frame population</span>
<span class="k">def</span> <span class="nf">_populate_mce_data</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">n_periods</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
    <span class="c1"># Create template data frame, for each period of leads added</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_periods</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="c1"># Set up values for new variables in-order</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">pd</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="n">n_periods</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">nm</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">nm</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Set values for new lead variables at time 0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Period</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>
    <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

    <span class="c1"># Append templated frame to end of data; better to concat as numpy</span>
    <span class="c1"># Otherwise pandas creates two FloatBlocks to be consolidated later</span>
    <span class="n">tmp2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">tmp</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np2df</span><span class="p">(</span>
        <span class="n">tmp2</span><span class="p">,</span>
        <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="o">+</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nm</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">nm</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_periods</span><span class="p">)],</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pyFRB/US  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pyfrbus.frbus</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    </div>
  </body>
</html>